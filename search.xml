<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>简述渲染管线</title>
    <url>/2021/08/01/pipline/</url>
    <content><![CDATA[<p>&emsp;&emsp;渲染管线主要分为三个阶段：应用程序阶段、几何阶段、光栅化阶段。</p>
<ul>
<li>应用程序阶段（CPU负责）：主要和CPU、内存打交道，诸如碰撞检测、场景图建立、视锥裁剪等算法在此阶段进行。在该阶段的最后，几何体数据（顶点坐标、法向量、纹理坐标等）<br>通过数据总线传送到图形硬件。</li>
<li>几何阶段（GPU负责）：主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射。在该阶段的最后，得到经过变换和投影之后的顶点坐标、颜色、纹理坐标。</li>
<li>光栅化阶段（GPU负责）：基于几何阶段输出的数据，为像素配色，最终得到最终渲染的图像。</li>
</ul>
<hr>
<h1 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h1><ol>
<li><p>从 object space 到 world space<br>&emsp;&emsp;object space coordinate 与其他物体没有任何参照关系，注意，这个概念非常重要，它是将 object space coordinate 和 worldspace coordinate 区分开来的关键。无论在现实世界，还是在计算机的虚拟空间中，物体都必须和一个固定的坐标原点进行参照才能确定自己所在的位置，这是world space coordinate<br>的实际意义所在。<br>&emsp;&emsp;我们将一个模型导入计算机后，就应该给它一个相对于坐标原点的位置，那么这个位置就是 world space coordinate，从 object space coordinate 到world space coordinate 的变换过程由一个四阶矩阵控制，通常称之为 world matrix。<br>&emsp;&emsp;光照计算通常是在 world coordinate space（世界坐标空间）中进行的，这也符合人类的生活常识。当然，也可以在 eye coordinate space 中得到相同的光照效果，因为，在同一观察空间中物体之间的相对关系是保存不变的。<br>&emsp;&emsp;顶点法向量在模型文件中属于 object space，在 GPU 的顶点程序中必须将法向量转换到 world space 中才能使用。<br>&emsp;&emsp;如同必须将顶点坐标从 object space 转换到 world space 中一样，但两者的转换矩阵是不同的。</p>
 <div class="note warning modern"><p>法向量从 object space 到 world space 的转换矩阵是 world matrix 的转置矩阵的逆矩阵</p>
</div>
</li>
<li><p>从 world space 到 eye space<br>&emsp;&emsp;所谓 eye space，即以 camera（视点或相机）为原点，由视线方向、视角和远近平面，共同组成一个梯形体的三维空间，称之为 viewing frustum（视锥）。</p>
</li>
<li><p>从 eye space 到 project and clip space<br>&emsp;&emsp;一旦顶点坐标被转换到 eye space 中，就需要判断哪些点是视点可见的。位于 viewing frustum 梯形体以内的顶点，被认定为可见，而超出这个梯形体之外的场景数据，会被视点去除（Frustum Culling，也称之为视锥裁剪）。这一步通常称之为“clip（裁剪）”，识别指定区域内或区域外的图形部分的过程称之为裁剪算法。</p>
</li>
<li><p>Primitive Assembly &amp;&amp; Triangle setup</p>
<ul>
<li>Primitive Assembly<br>&emsp;&emsp;图元装配即将顶点根据primitive（原始的连接关系）,还原出网格结构。网格由顶点和索引组成，在之前的流水线中是对顶点的处理，在这个阶段是根据索引将顶点链接在一起，组成线、面单元。之后就是对超出屏幕外的三角形进行裁剪，想象一下：一个三角形其中一个顶点在画面外，另外两个顶点在画面内，这是我们在屏幕上看到的就是一个四边形。然后将该四边形切成两个小的三角形。</li>
<li>Triangle Setup<br>&emsp;&emsp;处理三角形的过程被称为 Triangle  Setup。到目前位置，我们得到了一堆在屏幕坐标上的三角面片，这些面片是用于做光栅化的（Rasterizing）。</li>
</ul>
</li>
</ol>
<h1 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h1><ul>
<li>Rasterization<br>&emsp;&emsp;光栅化是将一个图元转变为一个二维图像的过程。二维图像上每个点都包含了颜色、深度和纹理数据。将该点和相关信息叫做一个片元（fragment）。光栅化的目的，是找出一个几何单元（比如三角形）所覆盖的像素。</li>
<li>Pixel Operation<br>&emsp;&emsp;Pixel operation 又称为 Raster Operation，其目的是计算出每个像素的颜色值。Pixel operation包含以下几个作用：<ol>
<li>消除遮挡面；</li>
<li>Texture operation，纹理操作，也就是根据像素的纹理坐标，查询对应的纹理值；</li>
<li>Blending 混色，根据目前已经画好的颜色，与正在计算的颜色的透明度（Alpha），混合为两种颜色，作为新的颜色输出。通常称之为 alpha 混合技术。 当在屏幕上绘制某个物体时，与每个像素都相关联的哟一个 RGB 颜色值和一个 Z 缓冲器深度值，另外一个称为是 alpha 值，可以根据需要生成并存储，用来描述给定像素处的物体透明度。如果 alpha 值为 1.0，则表示物体不透明如果值为 0，表示该物体是透明的。<div class="note info modern"><p>为了在场景中绘制透明物体，通常需要对物体进行排序。首先，绘制不透明的物体；然后，在不透明物体的上方，对透明物体按照由后到前的顺序进行混合处理。如果按照任意顺序进行混合，那么会产生严重的失真。既然需要排序，那么就需要用到 z buffer。</p>
</div></li>
<li>Filtering，将正在算的颜色经过某种 Filtering（滤波或者滤镜）后输出。可以理解为：经过一种数学运算后变成新的颜色值。<br>该阶段之后，像素的颜色值被写入帧缓存中。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Render</category>
      </categories>
      <tags>
        <tag>Render</tag>
        <tag>阳春白雪下里巴人</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CUDA的光线追踪器[1]</title>
    <url>/2021/08/15/CUDA_RayTracer_1/</url>
    <content><![CDATA[<p>&emsp;&emsp;绝大部分的光线追踪教程以CPU实现为主,该文章主要目的为笔者的学习记录,也希望今后能对其他学习者提供一些帮助<br>&emsp;&emsp;本文章中的光线追踪部分参考<a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">&lt;&lt; Ray Tracing in One Weekend &gt;&gt;</a><br>&emsp;&emsp;CUDA的基础知识则来自&lt;&lt; GPU高性能编程CUDA实战 &gt;&gt;一书</p>
<hr>
<p>&emsp;&emsp;首先简单地使用CUDA渲染出一张图片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cuda_runtime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;device_launch_parameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpu_bitmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;book.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cuda.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIM 256</span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="keyword">void</span> <span class="title">SetColor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> &amp;ir,<span class="keyword">int</span> &amp;ig,<span class="keyword">int</span> &amp;ib)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> r = (<span class="keyword">double</span>)x / (DIM - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">double</span> g = (<span class="keyword">double</span>)y / (DIM - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">double</span> b = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">	ir = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * r);</span><br><span class="line">	ig = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * g);</span><br><span class="line">	ib = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">255.999</span> * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">kernel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将threadIdx/BlockIdx映射到像素位置</span></span><br><span class="line">    <span class="keyword">int</span> x = blockIdx.x;</span><br><span class="line">    <span class="keyword">int</span> y = blockIdx.y;</span><br><span class="line">	<span class="keyword">int</span> offset = x + y * gridDim.x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">SetColor</span>(x, y, r, g, b);</span><br><span class="line"></span><br><span class="line">	ptr[offset * <span class="number">4</span> + <span class="number">0</span>] = r;</span><br><span class="line">	ptr[offset * <span class="number">4</span> + <span class="number">1</span>] = g;</span><br><span class="line">	ptr[offset * <span class="number">4</span> + <span class="number">2</span>] = b;</span><br><span class="line">	ptr[offset * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DataBlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* dev_bitmap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	DataBlock   data;</span><br><span class="line">	<span class="function">CPUBitmap <span class="title">bitmap</span><span class="params">(DIM, DIM)</span></span>;<span class="comment">//创建一个DIM*DIM大小的位图图像</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *dev_bitmap;<span class="comment">//接下来将在GPU上执行计算 因此在代码中声明一个指针用来保存设备上数据的副本</span></span><br><span class="line">	<span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaMalloc</span>((<span class="keyword">void</span>**)&amp;dev_bitmap,</span><br><span class="line">		bitmap.<span class="built_in">image_size</span>()));<span class="comment">//为了保存数据,需要cudaMalloc来分配内存</span></span><br><span class="line">	data.dev_bitmap = dev_bitmap;</span><br><span class="line">	<span class="function">dim3 <span class="title">grid</span><span class="params">(DIM, DIM)</span></span>;<span class="comment">//由于每个点的计算与其他点的计算都是相互独立的,</span></span><br><span class="line">						<span class="comment">//因此可以为每个需要计算的点都执行该函数的一个副本</span></span><br><span class="line">						<span class="comment">//在某些情况下使用二维索引会带来一定的帮助,显然在二维空间中计算函数值正属于这种情况</span></span><br><span class="line">						<span class="comment">//因此此处声明了一个二维的线程格</span></span><br><span class="line">	kernel &lt;&lt; &lt;grid, <span class="number">1</span> &gt;&gt; &gt; (dev_bitmap);<span class="comment">//将dim3变量grid传递给CUDA运行</span></span><br><span class="line">										<span class="comment">//之前分配的指针传递给kernel来保存计算结果</span></span><br><span class="line">	<span class="comment">//执行完kernel之后,设备上会生成计算结果,我们需要将这些结果复制回主机</span></span><br><span class="line">	<span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaMemcpy</span>(bitmap.<span class="built_in">get_ptr</span>(), </span><br><span class="line">				dev_bitmap,</span><br><span class="line">				bitmap.<span class="built_in">image_size</span>(),</span><br><span class="line">				cudaMemcpyDeviceToHost));</span><br><span class="line">	<span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaFree</span>(dev_bitmap));</span><br><span class="line">	bitmap.<span class="built_in">display_and_exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/CUDA/CUDA_Raytracer_1.png" alt=""></p>
]]></content>
      <categories>
        <category>RayTracing</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>RayTracing</tag>
      </tags>
  </entry>
</search>
